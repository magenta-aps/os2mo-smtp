import datetime
from datetime import timezone, timedelta
from unittest.mock import AsyncMock
from unittest.mock import MagicMock
from uuid import uuid4

from mo_smtp.autogenerated_graphql_client.address_data import AddressDataAddresses
from mo_smtp.autogenerated_graphql_client.employee_data import EmployeeDataEmployees
from mo_smtp.autogenerated_graphql_client.employee_name import EmployeeNameEmployees
from mo_smtp.autogenerated_graphql_client.manager_data import ManagerDataManagers
from mo_smtp.autogenerated_graphql_client.institution_address import (
    InstitutionAddressOrgUnits,
)
from mo_smtp.autogenerated_graphql_client.org_unit_ancestors import (
    OrgUnitAncestorsOrgUnits,
)
from mo_smtp.autogenerated_graphql_client.org_unit_data import OrgUnitDataOrgUnits
from mo_smtp.autogenerated_graphql_client.org_unit_relations import (
    OrgUnitRelationsOrgUnits,
)
from mo_smtp.autogenerated_graphql_client.ituser import (
    ItuserItusers,
    ItuserItusersObjectsCurrent,
)
import pytest
from fastramqpi.context import Context
from structlog.testing import capture_logs

from mo_smtp.agents import alert_on_manager_removal, alert_on_org_unit_without_relation
from mo_smtp.agents import inform_manager_on_employee_address_creation
from mo_smtp.agents import generate_ituser_email


@pytest.fixture
def dataloader() -> AsyncMock:
    return AsyncMock()


@pytest.fixture
def DataLoader(dataloader: AsyncMock) -> MagicMock:
    DataLoader = MagicMock()
    DataLoader.return_value = dataloader
    return DataLoader


@pytest.fixture
def email_client() -> MagicMock:
    return MagicMock()


@pytest.fixture
def context(dataloader: AsyncMock, email_client: MagicMock) -> Context:
    email_settings = MagicMock()
    email_settings.receivers = ["datagruppen@silkeborg.dk"]

    return Context(
        {
            "user_context": {
                "dataloader": dataloader,
                "email_client": email_client,
                "email_settings": email_settings,
            }
        }
    )


async def test_inform_manager_on_employee_address_creation_no_address(context: Context):
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj({"objects": []})
    with capture_logs() as cap_logs:
        await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "Address not found" in str(cap_logs)


async def test_inform_manager_on_employee_address_creation_no_employee(
    context: Context,
):
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "value": "test@example.com",
                        "employee_uuid": None,
                        "address_type": {"scope": "EMAIL"},
                    }
                }
            ]
        }
    )

    with capture_logs() as cap_logs:
        await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "The address does not belong to an employee" in str(cap_logs)


async def test_inform_manager_on_employee_address_creation_not_email(
    context: Context,
) -> None:
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "value": "not_an_email",
                        "employee_uuid": uuid4(),
                        "address_type": {"scope": "PHONE"},
                    }
                }
            ]
        }
    )

    with capture_logs() as cap_logs:
        await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "The address type is not EMAIL" in str(cap_logs)


async def test_inform_manager_on_employee_address_creation_multiple_emails(
    context: Context,
):
    employee_uuid = uuid4()
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "value": "test@example.com",
                        "employee_uuid": employee_uuid,
                        "address_type": {"scope": "EMAIL"},
                    }
                }
            ]
        }
    )

    mo.employee_data.return_value = EmployeeDataEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Mick Jagger",
                        "addresses": [
                            {"value": "test@example.com"},
                            {"value": "another@email.com"},
                        ],
                        "engagements": [],
                    }
                }
            ]
        }
    )

    with capture_logs() as cap_logs:
        await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "A previous email address exists" in str(cap_logs)


async def test_inform_manager_on_employee_address_creation_no_engagements(
    context: Context,
):
    employee_uuid = uuid4()
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "value": "test@example.com",
                        "employee_uuid": employee_uuid,
                        "address_type": {"scope": "EMAIL"},
                    }
                }
            ]
        }
    )

    mo.employee_data.return_value = EmployeeDataEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Mick Jagger",
                        "addresses": [
                            {"value": "test@example.com"},
                        ],
                        "engagements": [],
                    }
                }
            ]
        }
    )

    await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_called_once_with(
        receiver={"test@example.com"},
        subject="Registrering i MO",
        body="Denne besked er sendt som bekræftelse på at Mick Jagger er registreret i OS2MO.",
        texttype="plain",
    )


async def test_inform_manager_on_employee_address_creation(
    context: Context,
):
    employee_uuid = uuid4()
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "value": "test@example.com",
                        "employee_uuid": employee_uuid,
                        "address_type": {"scope": "EMAIL"},
                    }
                }
            ]
        }
    )

    mo.employee_data.return_value = EmployeeDataEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Mick Jagger",
                        "addresses": [
                            {"value": "test@example.com"},
                        ],
                        "engagements": [
                            {
                                "org_unit": [{"name": "Stones"}],
                                "managers": [
                                    {
                                        "person": [
                                            {
                                                "addresses": [
                                                    {"value": "manager@email.com"}
                                                ]
                                            }
                                        ]
                                    },
                                ],
                            }
                        ],
                    }
                }
            ]
        }
    )

    await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_called_once_with(
        receiver={"test@example.com"},
        cc={"manager@email.com"},
        subject="Registrering i MO",
        body="Denne besked er sendt som bekræftelse på at Mick Jagger er registreret i Stones",
        texttype="plain",
    )


async def test_inform_manager_on_employee_address_creation_multiple_engagements(
    context: Context,
):
    employee_uuid = uuid4()
    mo = AsyncMock()
    mo.address_data.return_value = AddressDataAddresses.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "value": "test@example.com",
                        "employee_uuid": employee_uuid,
                        "address_type": {"scope": "EMAIL"},
                    }
                }
            ]
        }
    )

    mo.employee_data.return_value = EmployeeDataEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Mick Jagger",
                        "addresses": [
                            {"value": "test@example.com"},
                        ],
                        "engagements": [
                            {
                                "org_unit": [{"name": "Stones"}],
                                "managers": [
                                    {
                                        "person": [
                                            {
                                                "addresses": [
                                                    {"value": "manager@email.com"}
                                                ]
                                            }
                                        ]
                                    },
                                ],
                            },
                            {
                                "org_unit": [{"name": "Rolling"}],
                                "managers": [
                                    {
                                        "person": [
                                            {
                                                "addresses": [
                                                    {
                                                        "value": "another_manager@email.com"
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                ],
                            },
                        ],
                    }
                }
            ]
        }
    )

    await inform_manager_on_employee_address_creation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_called_once()

    called_args = email_client.send_email.call_args[
        1
    ]  # Get the keyword arguments passed to the function
    body = called_args["body"]

    # Need to check like this, since 'Rolling' and 'Stones' comes in random order, and therefore the test will fail 50% of the time
    # Ensure both 'Rolling' and 'Stones' are in the body, regardless of order
    assert "Rolling" and "Stones" in body, (
        f"Expected 'Rolling' and 'Stones' to be in body, but got {body}"
    )

    # Also check that the rest of the parameters are correct
    assert called_args["receiver"] == {"test@example.com"}
    assert called_args["cc"] == {"another_manager@email.com", "manager@email.com"}
    assert called_args["subject"] == "Registrering i MO"
    assert called_args["texttype"] == "plain"


async def test_alert_on_manager_removal_manager_not_found(context: Context):
    mo = AsyncMock()
    mo.manager_data.return_value = ManagerDataManagers.parse_obj({"objects": []})
    with capture_logs() as cap_logs:
        await alert_on_manager_removal(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "Manager not found" in str(cap_logs)


async def test_alert_on_manager_removal_currently_employed(context: Context):
    mo = AsyncMock()
    mo.manager_data.return_value = ManagerDataManagers.parse_obj(
        {
            "objects": [
                {
                    "validities": [
                        {
                            "employee_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "validity": {
                                "from": datetime.datetime(
                                    2015,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    )

    with capture_logs() as cap_logs:
        await alert_on_manager_removal(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "Manager is currently employed" in str(cap_logs)


async def test_alert_on_manager_removal_future_to_date(context: Context):
    mo = AsyncMock()
    mo.manager_data.return_value = ManagerDataManagers.parse_obj(
        {
            "objects": [
                {
                    "validities": [
                        {
                            "employee_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "validity": {
                                "from": datetime.datetime(
                                    2015,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                                "to": datetime.datetime(
                                    2090,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                            },
                        }
                    ]
                }
            ]
        }
    )

    with capture_logs() as cap_logs:
        await alert_on_manager_removal(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_not_called()
    assert "to_date is in the future" in str(cap_logs)


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_manager_removal_past_to_date(context: Context):
    mo = AsyncMock()
    mo.manager_data.return_value = ManagerDataManagers.parse_obj(
        {
            "objects": [
                {
                    "validities": [
                        {
                            "employee_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "validity": {
                                "from": datetime.datetime(
                                    2015,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                                "to": datetime.datetime(
                                    2000,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                            },
                        }
                    ]
                }
            ]
        }
    )

    mo.employee_name.return_value = EmployeeNameEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Mick Jagger",
                    }
                }
            ]
        }
    )
    mo.org_unit_data.return_value = OrgUnitDataOrgUnits.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Rolling",
                        "user_key": "123stones",
                        "managers": [],
                    }
                }
            ]
        }
    )
    mo.org_unit_ancestors.return_value = OrgUnitAncestorsOrgUnits.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "ancestors": [{"name": "Rolling"}],
                        "name": "Stones",
                    }
                },
            ]
        }
    )
    await alert_on_manager_removal(context, uuid4(), None, mo)
    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_called_once()

    call_args = email_client.send_email.call_args_list[0]

    receiver, header, message, _ = call_args.args
    assert receiver == {"datagruppen@silkeborg.dk"}
    assert header == "En medarbejder er blevet fjernet fra lederfanen"
    assert "123stones" in message
    assert "Mick Jagger" in message
    assert "Rolling / Stones" in message


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_manager_vacant(context: Context):
    mo = AsyncMock()
    mo.manager_data.return_value = ManagerDataManagers.parse_obj(
        {
            "objects": [
                {
                    "validities": [
                        {
                            "employee_uuid": None,
                            "org_unit_uuid": uuid4(),
                            "validity": {
                                "from": datetime.datetime(
                                    2015,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                                "to": None,
                            },
                        }
                    ]
                }
            ]
        }
    )
    mo.employee_name.return_value = EmployeeNameEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "None",
                    }
                }
            ]
        }
    )
    mo.org_unit_data.return_value = OrgUnitDataOrgUnits.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Rolling",
                        "user_key": "123stones",
                        "managers": [],
                    }
                }
            ]
        }
    )
    mo.org_unit_ancestors.return_value = OrgUnitAncestorsOrgUnits.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "ancestors": [{"name": "Rolling"}],
                        "name": "Stones",
                    }
                },
            ]
        }
    )
    await alert_on_manager_removal(context, uuid4(), None, mo)
    email_client = context["user_context"]["email_client"]

    email_client.send_email.assert_called_once()
    call_args = email_client.send_email.call_args_list[0]
    receiver, header, message, _ = call_args.args
    assert receiver == {"datagruppen@silkeborg.dk"}
    assert header == "En medarbejder er blevet fjernet fra lederfanen"
    assert "123stones" in message
    assert "Vacant manager" in message
    assert "Rolling / Stones" in message


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_manager_send_to_org_unit_email(
    context: Context, monkeypatch: pytest.MonkeyPatch
):
    mo = AsyncMock()
    mo.manager_data.return_value = ManagerDataManagers.parse_obj(
        {
            "objects": [
                {
                    "validities": [
                        {
                            "employee_uuid": uuid4(),
                            "org_unit_uuid": uuid4(),
                            "validity": {
                                "from": datetime.datetime(
                                    2015,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                                "to": datetime.datetime(
                                    2000,
                                    1,
                                    1,
                                    tzinfo=timezone(timedelta(hours=1)),
                                ),
                            },
                        }
                    ]
                }
            ]
        }
    )
    mo.employee_name.return_value = EmployeeNameEmployees.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Mick Jagger",
                    }
                }
            ]
        }
    )
    mo.org_unit_data.return_value = OrgUnitDataOrgUnits.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "name": "Rolling",
                        "user_key": "123stones",
                        "root": [{"uuid": uuid4()}],
                        "managers": [],
                    }
                }
            ]
        }
    )
    mo.org_unit_ancestors.return_value = OrgUnitAncestorsOrgUnits.parse_obj(
        {
            "objects": [
                {
                    "current": {
                        "ancestors": [{"name": "Rolling"}],
                        "name": "Stones",
                    }
                },
            ]
        }
    )

    mo.institution_address.return_value = InstitutionAddressOrgUnits.parse_obj(
        {"objects": [{"current": {"addresses": [{"value": "org_unit@email.com"}]}}]}
    )

    with monkeypatch.context() as con:
        con.setenv("ALERT_MANAGER_REMOVAL_USE_ORG_UNIT_EMAILS", "True")
        await alert_on_manager_removal(context, uuid4(), None, mo)
    email_client = context["user_context"]["email_client"]

    email_client.send_email.assert_called_once()
    call_args = email_client.send_email.call_args_list[0]
    receiver, header, message, _ = call_args.args
    assert receiver == {"org_unit@email.com"}
    assert header == "En medarbejder er blevet fjernet fra lederfanen"
    assert "123stones" in message
    assert "Mick Jagger" in message
    assert "Rolling / Stones" in message


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_org_unit_without_relation_not_found(
    context: Context, monkeypatch: pytest.MonkeyPatch
):
    with monkeypatch.context() as con:
        con.setenv("ROOT_LOEN_ORG", str(uuid4()))
        mo = AsyncMock()

        mo.org_unit_relations.return_value = OrgUnitRelationsOrgUnits.parse_obj(
            {"objects": []}
        )

        with capture_logs() as cap_logs:
            await alert_on_org_unit_without_relation(context, uuid4(), None, mo)

        email_client = context["user_context"]["email_client"]
        email_client.send_email.assert_not_called()
        assert "Org unit not found" in str(cap_logs)


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_org_unit_not_in_loenorganisation(
    context: Context, monkeypatch: pytest.MonkeyPatch
):
    root_loen_org = uuid4()
    root_uuid = uuid4()

    with monkeypatch.context() as con:
        con.setenv("ROOT_LOEN_ORG", str(root_loen_org))

        mo = AsyncMock()
        mo.org_unit_relations.return_value = OrgUnitRelationsOrgUnits.parse_obj(
            {
                "objects": [
                    {
                        "current": {
                            "name": "org-unit-name",
                            "root": [{"uuid": root_uuid}],
                            "engagements": [
                                {"uuid": uuid4()},
                            ],
                            "related_units": [{"org_units": []}],
                        },
                    }
                ]
            }
        )

        with capture_logs() as cap_logs:
            await alert_on_org_unit_without_relation(context, uuid4(), None, mo)

        email_client = context["user_context"]["email_client"]
        email_client.send_email.assert_not_called()
        assert "Org unit is not in the Lønorganisation" in str(cap_logs)


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_org_unit_has_external_relation(
    context: Context, monkeypatch: pytest.MonkeyPatch
):
    root_loen_org = uuid4()

    with monkeypatch.context() as con:
        con.setenv("ROOT_LOEN_ORG", str(root_loen_org))
        org_unit_uuid = uuid4()

        mo = AsyncMock()
        mo.org_unit_relations.return_value = OrgUnitRelationsOrgUnits.parse_obj(
            {
                "objects": [
                    {
                        "current": {
                            "name": "org-unit-name",
                            "root": [{"uuid": root_loen_org}],
                            "engagements": [
                                {"uuid": uuid4()},
                            ],
                            "related_units": [
                                {
                                    "org_units": [
                                        {
                                            "uuid": org_unit_uuid,
                                            "root": [{"uuid": root_loen_org}],
                                        },
                                        {
                                            "uuid": uuid4(),
                                            "root": [{"uuid": uuid4()}],
                                        },
                                    ]
                                }
                            ],
                        },
                    }
                ]
            }
        )

        with capture_logs() as cap_logs:
            await alert_on_org_unit_without_relation(context, org_unit_uuid, None, mo)

        email_client = context["user_context"]["email_client"]
        email_client.send_email.assert_not_called()
        assert "Org unit has a relation outside of the Lønorganisation" in str(cap_logs)


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_alert_on_org_unit_sends_email(
    context: Context, monkeypatch: pytest.MonkeyPatch
):
    root_loen_org = uuid4()

    with monkeypatch.context() as con:
        con.setenv("ROOT_LOEN_ORG", str(root_loen_org))

        mo = AsyncMock()
        mo.org_unit_relations.return_value = OrgUnitRelationsOrgUnits.parse_obj(
            {
                "objects": [
                    {
                        "current": {
                            "name": "org-unit-name",
                            "root": [{"uuid": root_loen_org}],
                            "engagements": [
                                {"uuid": uuid4()},
                            ],
                            "related_units": [],
                        },
                    }
                ]
            }
        )
        mo.institution_address.return_value = InstitutionAddressOrgUnits.parse_obj(
            {"objects": [{"current": {"addresses": [{"value": "test@example.com"}]}}]}
        )

        await alert_on_org_unit_without_relation(context, uuid4(), None, mo)

    email_client = context["user_context"]["email_client"]

    email_client.send_email.assert_called_once_with(
        receiver={"test@example.com"},
        subject="Manglende relation i Lønorganisation",
        body="Denne besked er sendt som en påmindelse om at enheden: org-unit-name "
        "ikke er relateret til en enhed i Administrationsorganisationen.",
        texttype="plain",
    )


@pytest.mark.usefixtures("minimal_valid_settings")
async def test_ituser_events_sends_email(context: Context):
    mo = AsyncMock()
    ituser_test_data = ItuserItusersObjectsCurrent.parse_obj(
        {
            "user_key": "ADUSER-123",
            "rolebindings": [
                {"role": [{"name": "admin", "uuid": uuid4()}]},
                {"role": [{"name": "user", "uuid": uuid4()}]},
            ],
            "person": [{"name": "Mick Jagger", "uuid": uuid4()}],
            "itsystem": {"name": "Active Directory", "uuid": uuid4()},
        }
    )

    mo.ituser.return_value = ItuserItusers.parse_obj(
        {"objects": [{"current": ituser_test_data}]}
    )
    await generate_ituser_email(context, uuid4(), mo)

    email_client = context["user_context"]["email_client"]
    email_client.send_email.assert_called_once()

    call_args = email_client.send_email.call_args_list[0]
    receiver, header, message, _ = call_args.args

    assert receiver == {"datagruppen@silkeborg.dk"}
    assert header == "En IT-bruger er blevet oprettet i MO"
    assert "Active Directory" in message
    assert "ADUSER-123" in message
    assert "admin" in message
    assert "user" in message
    assert "Mick Jagger" in message


# TODO: Test cases where email won't be sent

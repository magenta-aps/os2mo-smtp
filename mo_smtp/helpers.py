# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import datetime
from uuid import UUID
from datetime import UTC
from more_itertools import one
from more_itertools import only

from sqlalchemy import select

from mo_smtp import depends
from mo_smtp.models import ManagerNotification
from mo_smtp.autogenerated_graphql_client.manager_data import (
    ManagerDataManagersObjectsValidities,
)


def extract_current_or_latest_validity(
    validities: list[ManagerDataManagersObjectsValidities],
):
    """
    Check each validity in a list of validities and return the one which is either
    valid today, or has the latest end-date
    """
    if len(validities) <= 1:
        return only(validities)

    def is_current(val: ManagerDataManagersObjectsValidities) -> bool:
        # Cannot use datetime.utcnow as it is not timezone aware
        now_utc = datetime.datetime.now(UTC)

        match (val.validity.from_, val.validity.to):
            case (start, None):
                assert start is not None
                return start < now_utc
            case (start, end):
                assert start is not None
                assert end is not None
                return start < now_utc < end
            case _:  # pragma: no cover
                raise AssertionError()

    # If any of the validities is valid today, return it
    current_validity = only(filter(is_current, validities))
    if current_validity:
        return current_validity
    # Otherwise return the latest
    # TODO: Does this actually make sense? - Should we not return the one which is the
    #       closest to now, rather than the one that is the furthest into the future?
    # Cannot use datetime.max directly as it is not timezone aware
    datetime_max_utc = datetime.datetime.max.replace(tzinfo=UTC)
    latest_validity = max(
        validities, key=lambda val: val.validity.to or datetime_max_utc
    )
    return latest_validity


def get_manager_end_date(validities: list) -> ManagerNotification | None:
    """
    Determine the manager's end date (termination or vacancy) for DB tracking.

    Returns a dict with:
      - employee_name (str or None if vacant)
      - org_unit_name (str)
      - end_date (datetime) â€” either termination or vacancy start
    """

    # Sort validities by 'from' ascending
    sorted_validities = sorted(validities, key=lambda v: v.validity.from_)

    latest = sorted_validities[-1]

    manager_uuid = latest.uuid
    # TODO: Do not use `one` here
    employee_uuid = one(latest.person).uuid if latest.person else None
    org_unit_uuid = one(latest.org_unit).uuid if latest.org_unit else None

    # Determine the end_date: either 'to' date for a scheduled termination, or 'from' date if vacant
    if employee_uuid:
        end_date = latest.validity.to
        if not end_date:
            # Active manager with no scheduled termination -> ignore
            return None
    else:
        # Vacant manager -> track from-date
        end_date = latest.validity.from_

    return ManagerNotification(
        manager_uuid=manager_uuid,
        employee_uuid=employee_uuid,
        org_unit_uuid=org_unit_uuid,
        end_date=end_date,
    )


async def fetch_manager_notifications_from_db(
    session: depends.Session, manager_uuid: UUID
) -> list[ManagerNotification]:
    stmt = select(ManagerNotification).where(
        ManagerNotification.manager_uuid == manager_uuid
    )
    scalar_result = await session.scalars(stmt)
    manager_notifications = scalar_result.all()

    return [manager_notification for manager_notification in manager_notifications]
